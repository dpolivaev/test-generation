package login.testgeneration

import static login.LoginTestDriver.EMail.*;
import static login.LoginTestDriver.Password.*;
import static login.LoginTestDriver.Page.*;
import static login.LoginTestDriver.Protocol.*;

import login.LoginTestDriver.EMail;
import login.LoginTestDriver.Password;
import login.LoginTestDriver.Protocol;

import static login.testgeneration.LoginOracles.*;

global 
	val arrangeSteps=stepCounter("arrange")
	val loginArrange = arrangeSteps.nextSubsequence(1)
	val submitArrange = arrangeSteps.nextSubsequence(2)

	val assertSteps=stepCounter("assert")
	val submitAssert = LoginStrategies.assertSteps.copy
	val formatAssert = LoginStrategies.assertSteps.copy

strategy loginTests
	apply TestStructure.structure

	let script.driver be "login/LoginTestDriver"
	let script.imports be "import static login.LoginTestDriver.Page.*;
						   import static login.LoginTestDriver.EMail.*;
						   import static login.LoginTestDriver.Password.*;
						   import static login.LoginTestDriver.Protocol.*;"

	let (loginArrange.next) be "go to page(:page)"
	let page be LOGIN_PAGE
	let lazy password be VALID_PASSWORD
	let lazy email be VALID_MAIL

	let act be "submit(:protocol)"{
		apply submitTest
	},
	"enter password(:password)"{
		apply formatTest
	}

strategy submitTest
	
	
	let script be "login/LoginSubmit"
	let (submitArrange.next) be "enter mail address(:email)"
	let (submitArrange.next) be "enter password(:password)"
	let (submitAssert.next) be "checkPage(:pageAfterSubmit)"

	let protocol be HTTP{
		let [R1] be "logging in with protocol HTTP not allowed"
	},
	HTTPS {
		let email be VALID_MAIL { let password be VALID_PASSWORD, INVALID_PASSWORD, NOT_ENTERED_PASSWORD},
		INVALID_MAIL { let password be VALID_PASSWORD},
		NOT_ENTERED_MAIL { let password be VALID_PASSWORD, NOT_ENTERED_PASSWORD}
	}

	rule pageAfterSubmit let pageAfterSubmit be :page{
		let (submitAssert.next) be "password field is empty"
		let (submitAssert.next) be "email field equals to (:email)"
		let [R4] be "check email and password fields after failed log-in"
	}

	rule pageAfterSubmit if traced loginOracle.isLoginSuccessful(:protocol as Protocol, :email as EMail, :password as Password)
		let pageAfterSubmit be LOGIN_SUCCESS_PAGE

strategy formatTest
	let script be "login/LoginFormat"
	let (formatAssert.next) be "entered password is not visible"
	let [R2] be :(formatAssert)

